const { Octokit } = require('@octokit/rest');

class GitHubService {
  constructor() {
    this.token = process.env.GITHUB_TOKEN;
    if (!this.token) {
      console.warn('Warning: GITHUB_TOKEN not set. PR creation will not work.');
    }
    this.octokit = this.token ? new Octokit({ auth: this.token }) : null;
  }

  async createFixPR({ repository, branch, commit, fixes, analysis, job_url, job_name }) {
    if (!this.octokit) {
      throw new Error('GitHub token not configured');
    }

    try {
      const [owner, repo] = repository.split('/');
      
      // Create a new branch for the fix
      const fixBranchName = `ci-fix/${branch}-${Date.now()}`;
      
      // Get the reference of the base branch
      const { data: ref } = await this.octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${branch}`,
      });

      // Create new branch
      await this.octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${fixBranchName}`,
        sha: commit || ref.object.sha,
      });

      console.log(`Created branch: ${fixBranchName}`);

      // Apply fixes if possible (for now, just create PR with recommendations)
      // In a full implementation, we would commit actual code changes here

      // Create PR body
      const prBody = this.generatePRBody(analysis, fixes, job_url, job_name);

      // Create pull request
      const { data: pr } = await this.octokit.pulls.create({
        owner,
        repo,
        title: `ðŸ¤– CI-Fixer: Auto-fix for ${job_name || 'CI failure'}`,
        head: fixBranchName,
        base: branch,
        body: prBody,
      });

      console.log(`Created PR: ${pr.html_url}`);

      // Add labels
      try {
        await this.octokit.issues.addLabels({
          owner,
          repo,
          issue_number: pr.number,
          labels: ['ci-fixer', 'automated', 'bug'],
        });
      } catch (e) {
        console.warn('Could not add labels:', e.message);
      }

      return {
        pr_url: pr.html_url,
        pr_number: pr.number,
        branch: fixBranchName,
      };

    } catch (error) {
      console.error('Error creating PR:', error.message);
      throw new Error(`Failed to create PR: ${error.message}`);
    }
  }

  generatePRBody(analysis, fixes, job_url, job_name) {
    let body = `## ðŸ¤– CI-Fixer Automated Analysis\n\n`;
    body += `This PR was automatically created by CI-Fixer to help resolve a CI failure.\n\n`;
    
    if (job_url) {
      body += `**Failed Job:** [${job_name || 'View Job'}](${job_url})\n\n`;
    }

    // Root cause
    if (analysis.root_cause) {
      body += `### ðŸ” Root Cause\n\n`;
      body += `${analysis.root_cause}\n\n`;
    }

    // Error type
    if (analysis.error_type) {
      body += `**Error Type:** \`${analysis.error_type}\`\n\n`;
    }

    // Suggested fixes
    if (fixes && fixes.length > 0) {
      body += `### ðŸ”§ Suggested Fixes\n\n`;
      fixes.forEach((fix, index) => {
        body += `#### ${index + 1}. ${fix.file || 'Unknown file'}\n\n`;
        body += `${fix.description}\n\n`;
        
        if (fix.line_number) {
          body += `**Line:** ${fix.line_number}\n\n`;
        }
        
        if (fix.code_change) {
          body += `\`\`\`\n${fix.code_change}\n\`\`\`\n\n`;
        }
      });
    }

    // Instructions
    if (analysis.instructions && analysis.instructions.length > 0) {
      body += `### ðŸ“‹ Steps to Fix\n\n`;
      analysis.instructions.forEach((instruction, index) => {
        body += `${index + 1}. ${instruction}\n`;
      });
      body += `\n`;
    }

    // Additional info
    if (analysis.fallback) {
      body += `\n---\n`;
      body += `*Note: This analysis was generated using rule-based detection. For more accurate AI-powered analysis, configure GEMINI_API_KEY.*\n\n`;
    }

    body += `---\n`;
    body += `*ðŸ¤– Generated by CI-Fixer | [Learn More](https://github.com/${process.env.GITHUB_REPOSITORY || 'your-org/ci-fixer'})*\n`;

    return body;
  }

  async applyCodeFixes(owner, repo, branch, fixes) {
    // This would implement actual code changes
    // For MVP, we'll just create the PR with recommendations
    console.log('Code fix application not yet implemented');
    return [];
  }
}

module.exports = new GitHubService();
