const { Octokit } = require('@octokit/rest');

const octokit = new Octokit({
  auth: process.env.GITHUB_TOKEN
});

async function createFixPR(owner, repo, baseBranch, fixes, title, description) {
  try {
    if (!process.env.GITHUB_TOKEN) {
      throw new Error('GITHUB_TOKEN not configured');
    }

    // Create a new branch
    const branchName = `ci-fixer/auto-fix-${Date.now()}`;
    
    // Get the latest commit SHA from base branch
    const { data: refData } = await octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${baseBranch}`
    });
    
    const baseSha = refData.object.sha;
    
    // Create new branch
    await octokit.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branchName}`,
      sha: baseSha
    });
    
    // Apply fixes to files
    for (const fix of fixes) {
      try {
        // Get current file content
        let currentContent = '';
        let currentSha = null;
        
        try {
          const { data: fileData } = await octokit.repos.getContent({
            owner,
            repo,
            path: fix.file,
            ref: branchName
          });
          
          currentContent = Buffer.from(fileData.content, 'base64').toString('utf8');
          currentSha = fileData.sha;
        } catch (error) {
          // File doesn't exist, will create new
          console.log(`File ${fix.file} doesn't exist, will create new`);
        }
        
        // Apply the fix
        let newContent;
        if (fix.original_code && currentContent.includes(fix.original_code)) {
          newContent = currentContent.replace(fix.original_code, fix.fixed_code);
        } else {
          // If original code not found or not provided, append the fix
          newContent = fix.fixed_code;
        }
        
        // Update or create file
        await octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: fix.file,
          message: `Fix: ${fix.description}`,
          content: Buffer.from(newContent).toString('base64'),
          branch: branchName,
          sha: currentSha
        });
        
        console.log(`Applied fix to ${fix.file}`);
      } catch (error) {
        console.error(`Error applying fix to ${fix.file}:`, error.message);
        // Continue with other fixes
      }
    }
    
    // Create pull request
    const prTitle = title || 'ðŸ¤– CI-Fixer: Automated fix for CI failure';
    const prBody = description || `This PR was automatically generated by CI-Fixer to address a CI failure.

## Fixes Applied:
${fixes.map(f => `- **${f.file}**: ${f.description}`).join('\n')}

Please review the changes carefully before merging.`;
    
    const { data: pr } = await octokit.pulls.create({
      owner,
      repo,
      title: prTitle,
      body: prBody,
      head: branchName,
      base: baseBranch
    });
    
    console.log(`Created PR #${pr.number}: ${pr.html_url}`);
    
    return pr;
  } catch (error) {
    console.error('GitHub API error:', error);
    throw new Error(`Failed to create PR: ${error.message}`);
  }
}

async function getWorkflowRunLogs(owner, repo, runId) {
  try {
    const { data: jobs } = await octokit.actions.listJobsForWorkflowRun({
      owner,
      repo,
      run_id: runId
    });
    
    let logs = [];
    
    for (const job of jobs.jobs) {
      if (job.conclusion === 'failure') {
        try {
          const { data: jobLogs } = await octokit.actions.downloadJobLogsForWorkflowRun({
            owner,
            repo,
            job_id: job.id
          });
          
          logs.push({
            job_name: job.name,
            logs: jobLogs
          });
        } catch (error) {
          console.error(`Error fetching logs for job ${job.id}:`, error.message);
        }
      }
    }
    
    return logs;
  } catch (error) {
    console.error('Error fetching workflow logs:', error);
    throw new Error(`Failed to fetch logs: ${error.message}`);
  }
}

module.exports = { createFixPR, getWorkflowRunLogs };
